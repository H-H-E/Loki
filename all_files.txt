Command: tree -I 'node_modules' && find . -type f \( -name '*.ts' -o -name '*.tsx' \) ! -path './node_modules/*' -print -exec cat {} \; -exec echo '------------------------' \;
.
├── @
│   ├── components
│   │   └── ui
│   └── lib
│       └── utils.ts
├── LICENSE
├── README.md
├── all_files.txt
├── app
│   └── globals.css
├── components
│   ├── DropDown.tsx
│   ├── Footer.tsx
│   ├── GitHub.tsx
│   ├── GoogleSearchEngine.js
│   ├── Header.tsx
│   ├── LoadingDots.tsx
│   ├── LyricCard.tsx
│   ├── LyricsGeneratorForm.tsx
│   ├── badge.tsx
│   ├── button.tsx
│   └── card.tsx
├── components.json
├── next-env.d.ts
├── next.config.js
├── package-lock.json
├── package.json
├── pages
│   ├── _app.tsx
│   ├── _document.tsx
│   ├── api
│   │   ├── generate.ts
│   │   └── retrieve.ts
│   ├── history
│   ├── history.tsx
│   └── index.tsx
├── postcss.config.js
├── public
│   ├── 1-black.png
│   ├── 2-black.png
│   ├── analytics.png
│   ├── dark.png
│   ├── favicon.ico
│   ├── light.png
│   ├── lokilyrics.png
│   ├── og-image.png
│   ├── poiesis.png
│   ├── vercel.svg
│   ├── vercelLogo.png
│   └── writingIcon.png
├── styles
│   ├── globals.css
│   └── loading-dots.module.css
├── tailwind.config.js
├── tsconfig.json
└── utils
    └── OpenAIStream.ts

13 directories, 45 files
./utils/OpenAIStream.ts
import {
  createParser,
  ParsedEvent,
  ReconnectInterval,
} from "eventsource-parser";

export type ChatGPTAgent = "user" | "system";

export interface ChatGPTMessage {
  role: ChatGPTAgent;
  content: string;
}

export interface OpenAIStreamPayload {
  model: string;
  messages: ChatGPTMessage[];
  temperature: number;
  top_p: number;
  frequency_penalty: number;
  presence_penalty: number;
  max_tokens: number;
  stream: boolean;
  n: number;
}

export async function OpenAIStream(payload: OpenAIStreamPayload) {
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${process.env.OPENAI_API_KEY ?? ""}`,
    },
    method: "POST",
    body: JSON.stringify(payload),
  });

  const readableStream = new ReadableStream({
    async start(controller) {
      // callback
      const onParse = (event: ParsedEvent | ReconnectInterval) => {
        if (event.type === "event") {
          const data = event.data;
          controller.enqueue(encoder.encode(data));
        }
      }

      // optimistic error handling
      if (res.status !== 200) {
        const data = {
          status: res.status,
          statusText: res.statusText,
          body: await res.text(),
        }
        console.log(`Error: recieved non-200 status code, ${JSON.stringify(data)}`);
        controller.close();
        return
      }
        
      // stream response (SSE) from OpenAI may be fragmented into multiple chunks
      // this ensures we properly read chunks and invoke an event for each SSE event stream
      const parser = createParser(onParse);
      // https://web.dev/streams/#asynchronous-iteration
      for await (const chunk of res.body as any) {
        parser.feed(decoder.decode(chunk));
      }
    },
  });

  let counter = 0;
  const transformStream = new TransformStream({
    async transform(chunk, controller) {
      const data = decoder.decode(chunk);
      // https://beta.openai.com/docs/api-reference/completions/create#completions/create-stream
      if (data === "[DONE]") {
        controller.terminate();
        return;
      }
      try {
        const json = JSON.parse(data);
        const text = json.choices[0].delta?.content || "";
        if (counter < 2 && (text.match(/\n/) || []).length) {
          // this is a prefix character (i.e., "\n\n"), do nothing
          return;
        }
        // stream transformed JSON resposne as SSE
        const payload = {text: text};
        // https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(payload)}\n\n`)
        );
        counter++;
      } catch (e) {
        // maybe parse error
        controller.error(e);
      }
    },
  });

  return readableStream.pipeThrough(transformStream);
}
------------------------
./next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
------------------------
./components/LyricsGeneratorForm.tsx
// components/LyricsGeneratorForm.tsx

import React from 'react';
import LyricCard from './LyricCard';

interface LyricsGeneratorFormProps {
  topic: string;
  setTopic: (topic: string) => void;
  originalLyrics: string;
  setOriginalLyrics: (lyrics: string) => void;
  generateLyrics: (e: React.FormEvent<HTMLFormElement>) => Promise<void>;

  loading: boolean;
  generatedLyrics: string;
}

const LyricsGeneratorForm: React.FC<LyricsGeneratorFormProps> = ({
  topic,
  setTopic,
  originalLyrics,
  setOriginalLyrics,
  generateLyrics,
  loading,
  generatedLyrics,
}) => {
    const copyToClipboard = () => {
        navigator.clipboard.writeText(generatedLyrics);
      };
  return (
    <div className="">
      <h2 className="text-2xl mx-auto text-center font-bold">
        2: Pick a Topic
      </h2>
      <div className="flex flex-col space-y-4 mt-4 order-2">
        <input
          className="p-2 max-w-sm mx-auto border text-center rounded"
          placeholder="Topic"
          value={topic}
          onChange={(e) => setTopic(e.target.value)}
        />
        <textarea
          className="p-2 border max-w-md mx-auto text-center rounded"
          placeholder="Original Lyrics"
          rows={10}
          value={originalLyrics}
          onChange={(e) => setOriginalLyrics(e.target.value)}
        ></textarea>
      
      <form className="flex flex-col space-y-4 mt-4 order-2"
  onSubmit={(e) => {
    e.preventDefault();
    generateLyrics(e);
  }}
>
  <button
    type="submit"  // Note the type="submit"
    className="p-2 bg-black text-white max-w-sm mx-auto rounded"
  >
    Generate Lyrics
  </button>
</form>

        {generatedLyrics && (
          <LyricCard lyrics={generatedLyrics} />
        )}
      </div>
    </div>
  );
};

export default LyricsGeneratorForm;------------------------
./components/LoadingDots.tsx
import styles from "../styles/loading-dots.module.css";

const LoadingDots = ({
  color = "#000",
  style = "small",
}: {
  color: string;
  style: string;
}) => {
  return (
    <span className={style == "small" ? styles.loading2 : styles.loading}>
      <span style={{ backgroundColor: color }} />
      <span style={{ backgroundColor: color }} />
      <span style={{ backgroundColor: color }} />
    </span>
  );
};

export default LoadingDots;

LoadingDots.defaultProps = {
  style: "small",
};
------------------------
./components/card.tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
------------------------
./components/LyricCard.tsx
/**
 * v0 by Vercel.
 * @see https://v0.dev/t/M3idgABmkME
 */
import { Button } from "./button"
import { CardTitle, CardHeader, CardContent, CardFooter, Card } from "./card"
import { Badge } from "./badge"

export default function LyricCard({ lyrics }: { lyrics: string }) {
  return (
    <div>
      <div>
        <Button className="mb-4" variant="outline">
          <svg
            className=" h-6 w-6 mr-2"
            fill="none"
            height="24"
            stroke="currentColor"
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            viewBox="0 0 24 24"
            width="24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <line x1="4" x2="20" y1="12" y2="12" />
            <line x1="4" x2="20" y1="6" y2="6" />
            <line x1="4" x2="20" y1="18" y2="18" />
          </svg>
          My History
        </Button>
      </div>
      <div className="w-80 mt-2">
        <div>
          <div className="text-lg font-semibold px-4 py-2">Generated Lyrics</div>
          <div className="px-4 py-2 hover:bg-gray-200 dark:hover:bg-gray-700">
            <Card>
              <CardHeader className="flex items-center space-x-4">
                <img
                  alt="Album Cover"
                  className="rounded-lg"
                  height="80"
                  src="/placeholder.svg"
                  style={{
                    aspectRatio: "80/80",
                    objectFit: "cover",
                  }}
                  width="80"
                />
                <div>
                  <CardTitle className="text-xl font-semibold">Song Title</CardTitle>
                  <p className="text-sm text-gray-500 dark:text-gray-300">Artist Name</p>
                </div>
              </CardHeader>
              <textarea className="p-6 text-sm"
                placeholder="Original Lyrics"
                rows={10}
                value={lyrics}>     </textarea>
              <CardFooter className="flex justify-between items-center">
                <Badge className="items-center" variant="outline">
                  <svg
                    className=" h-3.5 w-3.5 -translate-x-1"
                    fill="none"
                    height="24"
                    stroke="currentColor"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    viewBox="0 0 24 24"
                    width="24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path d="M12 20.94c1.5 0 2.75 1.06 4 1.06 3 0 6-8 6-12.22A4.91 4.91 0 0 0 17 5c-2.22 0-4 1.44-5 2-1-.56-2.78-2-5-2a4.9 4.9 0 0 0-5 4.78C2 14 5 22 8 22c1.25 0 2.5-1.06 4-1.06Z" />
                    <path d="M10 2c1 .5 2 2 2 5" />
                  </svg>
                  AI-generated
                </Badge>
                <Button size="sm" variant="secondary">
                  View More
                </Button>
              </CardFooter>
            </Card>
          </div>
        </div>
      </div>
    </div>
  )
}
------------------------
./components/GitHub.tsx
export default function Github({ className }: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      fill="currentColor"
      viewBox="0 0 24 24"
      className={className}
    >
      <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
    </svg>
  );
}
------------------------
./components/Footer.tsx
import Link from "next/link";

export default function Footer() {
  return (
    <footer className="text-center h-16 sm:h-20 w-full sm:pt-2 pt-4 border-t mt-5 flex sm:flex-row flex-col justify-between items-center px-3 space-y-3 sm:mb-0 mb-3">
  
    </footer>
  );
}
------------------------
./components/DropDown.tsx
import { Menu, Transition } from "@headlessui/react";
import {
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@heroicons/react/20/solid";
import { Fragment } from "react";

function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(" ");
}

export type VibeType = "Professional" | "Casual" | "Funny";

interface DropDownProps {
  vibe: VibeType;
  setVibe: (vibe: VibeType) => void;
}

let vibes: VibeType[] = ["Professional", "Casual", "Funny"];

export default function DropDown({ vibe, setVibe }: DropDownProps) {
  return (
    <Menu as="div" className="relative block text-left w-full">
      <div>
        <Menu.Button className="inline-flex w-full justify-between items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-black">
          {vibe}
          <ChevronUpIcon
            className="-mr-1 ml-2 h-5 w-5 ui-open:hidden"
            aria-hidden="true"
          />
          <ChevronDownIcon
            className="-mr-1 ml-2 h-5 w-5 hidden ui-open:block"
            aria-hidden="true"
          />
        </Menu.Button>
      </div>

      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items
          className="absolute left-0 z-10 mt-2 w-full origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none"
          key={vibe}
        >
          <div className="">
            {vibes.map((vibeItem) => (
              <Menu.Item key={vibeItem}>
                {({ active }) => (
                  <button
                    onClick={() => setVibe(vibeItem)}
                    className={classNames(
                      active ? "bg-gray-100 text-gray-900" : "text-gray-700",
                      vibe === vibeItem ? "bg-gray-200" : "",
                      "px-4 py-2 text-sm w-full text-left flex items-center space-x-2 justify-between"
                    )}
                  >
                    <span>{vibeItem}</span>
                    {vibe === vibeItem ? (
                      <CheckIcon className="w-4 h-4 text-bold" />
                    ) : null}
                  </button>
                )}
              </Menu.Item>
            ))}
          </div>
        </Menu.Items>
      </Transition>
    </Menu>
  );
}
------------------------
./components/Header.tsx
import Image from "next/image";
import Link from "next/link";
import{Button }  from "../components/button"

export default function Header() {
  return (
    <header className="flex justify-center items-center w-full mt-5 border-b-2 pb-7 sm:px-4 px-2">
      <Link href="/" className="flex space-x-3">
      <h1 className="sm:text-3xl pt-6   text-xl font-bold ml-2 tracking-tight">
         Loki 
       </h1>
       <br></br>
        <Image
          alt="header text"
          src="/lokilyrics.png"
          className=" font-bold ml-2 tracking-tight"
          width={90}
          height={90}
         
        />
     
      </Link>
      <a
        href="https://2022.poiesis.education"
        target="_blank"
        rel="noreferrer"
      >
      </a>
      <Button className="ml-auto" >

        <Link className="text-white bg-blue-500 hover:bg-blue-700 text-sm font-semibold py-2 px-4 rounded" href="./history">
          
            History
          
        </Link>




      </Button>
      
    </header>
  );
}
------------------------
./components/badge.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
------------------------
./components/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
------------------------
./pages/index.tsx
import type { NextPage } from "next";
import { useRef, useState } from "react";
import Header from "../components/Header";
import LoadingDots from "../components/LoadingDots";
import  LyricsGeneratorForm  from '../components/LyricsGeneratorForm';

import {
  createParser,
  ParsedEvent,
  ReconnectInterval,
} from "eventsource-parser";

import GoogleSearchEngine from "../components/GoogleSearchEngine";

import image1 from "../public/light.png";
import image2 from "../public/dark.png";

interface LyricsDecisionCardProps {
  onUseLyrics: (lyrics: string) => void;
}

interface LyricsData {
  lyrics: string;
  image: string;
}

const fetchOriginalLyrics = async (
  trackName: string,
  artistName: string
): Promise<LyricsData> => {
  try {
    const response = await fetch(
      `/api/retrieve?track_name=${trackName}&artist_name=${artistName}`
    );
    if (response.ok) {
      const data: LyricsData = await response.json();
      return data;
    }
  } catch (error) {
    console.error("Failed to fetch lyrics:", error);
  }
  return { lyrics: "", image: "" };
};

const LyricsDecisionCard: React.FC<LyricsDecisionCardProps> = ({
  onUseLyrics,
}) => {
  const [showLyrics, setShowLyrics] = useState(false);
  const [lyrics, setLyrics] = useState("");
  const [image, setImage] = useState("");
  const [artistName, setArtistName] = useState("");
  const [trackName, setTrackName] = useState("");

  const tryAgain = () => {
    setShowLyrics(false);
    setLyrics("");
    setImage("");
  };

  const fetchAndShowLyrics = async () => {
    const { lyrics, image } = await fetchOriginalLyrics(trackName, artistName);
    setLyrics(lyrics);
    setImage(image);
    setShowLyrics(true);
  };

  return (
    <div className="order-1 flex flex-col space-y-4 container-mx-auto">
      {!showLyrics ? (
        <div className="object-center mx-auto space-y-4 flex flex-col">
          <input
            className="p-2 border rounded mx-auto max-w-sm"
            type="text"
            placeholder="Artist Name"
            value={artistName}
            onChange={(e) => setArtistName(e.target.value)}
          />
          <input
            className="p-2 border rounded mx-auto max-w-sm"
            type="text"
            placeholder="Track Name"
            value={trackName}
            onChange={(e) => setTrackName(e.target.value)}
          />
          <button
            className="p-2 bg-black text-white max-w-sm mx-auto rounded"
            onClick={fetchAndShowLyrics}
          >
            Fetch Lyrics
          </button>
        </div>
      ) : (
        <div className="sticky">
          <div className="bg-white rounded p-4 shadow-md flex flex-col items-center space-y-2 max-w-md mx-auto ">
            <h2 className="text-xl font-semibold sticky-0 items-center">
              Original Lyrics
            </h2>
            {image && (
              <img
                className="w-40 h-40 object-center rounded"
                src={image}
                alt={`${trackName} by ${artistName}`}
              />
            )}
            <div className="flex space-x-2">
              <button
                className="p-2 bg-black text-white rounded"
                onClick={() => onUseLyrics(lyrics)}
              >
                Use These Lyrics
              </button>
              <button
                className="p-2 bg-blue-700 text-white rounded"
                onClick={tryAgain}
              >
                Try Again
              </button>
            </div>
            <div className="max-h-40 overflow-y-auto">
              <p className="text-center whitespace-pre-line">{lyrics}</p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
const ClickableImage: React.FC = () => {
  const [isImageOne, setIsImageOne] = useState(true);

  const handleClick = () => {
    setIsImageOne(!isImageOne);
  };

  return (
    <img
      className="w-40 h-40 mx-auto rounded"
      src={isImageOne ? '/dark.png' : '/light.png' }
      alt="clickable"
      onClick={handleClick}
    />
  );
};







const LyricsGenerator: NextPage = () => {
  const [loading, setLoading] = useState(false);
  const [topic, setTopic] = useState("");
  const [originalLyrics, setOriginalLyrics] = useState("");
  const [generatedLyrics, setGeneratedLyrics] = useState("");

  const lyricsRef = useRef<null | HTMLDivElement>(null);

  const scrollToLyrics = () => {
    if (lyricsRef.current !== null) {
      lyricsRef.current.scrollIntoView({ behavior: "smooth" });
    }
  };
  const fetchOriginalLyrics = async (trackName: string, artistName: string) => {
    try {
      const response = await fetch(`/api/${trackName}/${artistName}`);
      if (response.ok) {
        const data = await response.json();
        setOriginalLyrics(data.lyrics);
      }
    } catch (error) {
      console.error("Failed to fetch lyrics:", error);
    }
  };

  const generateLyrics = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setGeneratedLyrics("");
    setLoading(true);

    const prompt = `Your task is to rewrite the lyrics of a given song to revolve around a specific topic provided. The goal is to keep the original rhythm and structure of the song, adapting and substitifying words to create a new set of lyrics in line with the given theme. You should stay true to the song's rhyme scheme and musicality, whilst making sure the lyrics provide a coherent narrative around the topic and can be sung with the same tune of the song. Your input would be the original lyrics of the song, along with the specified topic, and your output would be the adapted lyrics revolving around that topic. While rewriting, remember to not only focus on thematic relevance but also ensure that your lyrics preserve the musical appeal of the original song. Essentially, you're creating a completely different version of the song that can stand on its own while staying true to the original's musical qualities. Topic:  "${topic}" Original lyrics: ${originalLyrics} Please provide the lyrics line by line.`;

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        prompt,
      }),
    });

    if (!response.ok) {
      throw new Error(response.statusText);
    }

    const data = response.body;
    if (!data) {
      return;
    }

    const onParse = (event: ParsedEvent | ReconnectInterval) => {
      if (event.type === "event") {
        const data = event.data;
        try {
          const text = JSON.parse(data).text ?? "";
          setGeneratedLyrics((prev) => prev + text);
        } catch (e) {
          console.error(e);
        }
      }
    };

    const reader = data.getReader();
    const decoder = new TextDecoder();
    const parser = createParser(onParse);
    let done = false;
    while (!done) {
      const { value, done: doneReading } = await reader.read();
      done = doneReading;
      const chunkValue = decoder.decode(value);
      parser.feed(chunkValue);
    }
    scrollToLyrics();
    setLoading(false);
  };

  return (
    <div className="container mx-auto p-4 max-height">
      <Header />
      <main className="space-y-8 object-center">

  


      <LyricsDecisionCard
            onUseLyrics={(lyrics: string) => setOriginalLyrics(lyrics)}
          />

        <LyricsGeneratorForm
            topic={topic}
            setTopic={setTopic}
            originalLyrics={originalLyrics}
            setOriginalLyrics={setOriginalLyrics}
            generateLyrics={generateLyrics}
            loading={loading}
            generatedLyrics={generatedLyrics}
          />
        
         
      </main>
    </div>
  );
};

export default LyricsGenerator;
------------------------
./pages/_document.tsx
import Document, { Head, Html, Main, NextScript } from "next/document";

class MyDocument extends Document {
  render() {
    return (
      <Html lang="en">
        <Head>
          <link rel="icon" href="/favicon.ico" />
          <meta
            name="description"
            content="Give a song and a topic, get a song about that topic"
          />
          <meta property="og:site_name" content="poet.poiesis.education" />
          <meta
            property="og:description"
            content="Give a song and a topic, get a song about that topic"
          />
          <meta property="og:title" content="Twitter Bio Generator" />
          <meta name="twitter:card" content="summary_large_image" />
          <meta name="twitter:title" content="Twitter Bio Generator" />
          <meta
            name="twitter:description"
            content="Give a song and a topic, get a song about that topic"
          />
          <meta
            property="og:image"
            content="https://poet.poiesis.education/og-image.png"
          />
          <meta
            name="twitter:image"
            content="https://poet.poiesis.education/og-image.png"
          />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;
------------------------
./pages/history.tsx
import Header from "../components/Header"



export default function Page() {
    return(
    <div className="container mx-auto p-4 max-height">

        <Header/>


    </div>)
  }





------------------------
./pages/api/retrieve.ts
import { NextApiRequest, NextApiResponse } from 'next';
import axios from 'axios';
import rateLimit from 'axios-rate-limit';

// Define Axios error type
interface AxiosError extends Error {
  response?: {
    status: number;
    data: any;
  };
}

const http = rateLimit(axios.create(), { maxRequests: 150, perMilliseconds: 60 * 60 * 1000 });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { track_name, artist_name } = req.query;

  try {
    const response = await http.get(`https://lyrist.vercel.app/api/${track_name}/${artist_name}`);
    const { lyrics, image } = response.data;
    if (lyrics && image) {
      res.status(200).json({ lyrics, image });
    } else {
      res.status(404).json({ message: "Lyrics or image not found" });
    }
  } catch (error: unknown) {
    if (error instanceof Error) {
      const axiosError = error as AxiosError;
      res.status(axiosError.response?.status || 500).json(axiosError.response?.data || {});
    } else {
      res.status(500).json({ message: "Unknown error" });
    }
  }
}
------------------------
./pages/api/generate.ts
import { OpenAIStream, OpenAIStreamPayload } from "../../utils/OpenAIStream";

if (!process.env.OPENAI_API_KEY) {
  throw new Error("Missing env var from OpenAI");
}

// Default to 'gpt-4' if MODEL_TYPE isn't specified
const modelType = process.env.MODEL_TYPE || 'gpt-4';

export const config = {
  runtime: "edge",
};

const handler = async (req: Request): Promise<Response> => {
  const { prompt } = (await req.json()) as {
    prompt?: string;
  };

  if (!prompt) {
    return new Response("No prompt in the request", { status: 400 });
  }

  const payload: OpenAIStreamPayload = {
    model: modelType,  
    messages: [{ role: "user", content: prompt }],
    temperature: 0.7,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
    max_tokens: 1000,
    stream: true,
    n: 1,
  };

  const stream = await OpenAIStream(payload);
  return new Response(
    stream, {
      headers: new Headers({
        'Cache-Control': 'no-cache',
      })
    }
  );
};

export default handler;
------------------------
./pages/_app.tsx
import { Analytics } from "@vercel/analytics/react";
import type { AppProps } from "next/app";
import "../styles/globals.css";

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Component {...pageProps} />
      <Analytics />
    </>
  );
}

export default MyApp;
------------------------
./@/lib/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"
 
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
------------------------
