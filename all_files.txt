.
├── @
│   └── components
├── LICENSE
├── README.md
├── all_files.txt
├── app
├── components
│   ├── DropDown.tsx
│   ├── Footer.tsx
│   ├── GitHub.tsx
│   ├── GoogleSearchEngine.js
│   ├── Header.tsx
│   ├── History.tsx
│   ├── LoadingDots.tsx
│   ├── LyricsGeneratorForm.tsx
│   ├── lib
│   ├── ui
│   │   ├── button.tsx
│   │   ├── card.tsx
│   │   ├── carousel.tsx
│   │   └── table.tsx
│   └── utils.ts
├── components.json
├── next-env.d.ts
├── next.config.js
├── package-lock.json
├── package.json
├── pages
│   ├── _app.tsx
│   ├── _document.tsx
│   ├── api
│   │   ├── generate.ts
│   │   └── retrieve.ts
│   ├── history
│   └── index.tsx
├── postcss.config.js
├── public
│   ├── 1-black.png
│   ├── 2-black.png
│   ├── analytics.png
│   ├── dark.png
│   ├── favicon.ico
│   ├── light.png
│   ├── lokilyrics.png
│   ├── og-image.png
│   ├── placeholder.svg
│   ├── poiesis.png
│   ├── vercel.svg
│   ├── vercelLogo.png
│   └── writingIcon.png
├── styles
│   ├── globals.css
│   └── loading-dots.module.css
├── tailwind.config.js
├── tsconfig.json
└── utils
    └── OpenAIStream.ts

13 directories, 45 files
./utils/OpenAIStream.ts
import {
  createParser,
  ParsedEvent,
  ReconnectInterval,
} from "eventsource-parser";

export type ChatGPTAgent = "user" | "system";

export interface ChatGPTMessage {
  role: ChatGPTAgent;
  content: string;
}

export interface OpenAIStreamPayload {
  model: string;
  messages: ChatGPTMessage[];
  temperature: number;
  top_p: number;
  frequency_penalty: number;
  presence_penalty: number;
  max_tokens: number;
  stream: boolean;
  n: number;
}

export async function OpenAIStream(payload: OpenAIStreamPayload) {
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${process.env.OPENAI_API_KEY ?? ""}`,
    },
    method: "POST",
    body: JSON.stringify(payload),
  });

  const readableStream = new ReadableStream({
    async start(controller) {
      // callback
      const onParse = (event: ParsedEvent | ReconnectInterval) => {
        if (event.type === "event") {
          const data = event.data;
          controller.enqueue(encoder.encode(data));
        }
      }

      // optimistic error handling
      if (res.status !== 200) {
        const data = {
          status: res.status,
          statusText: res.statusText,
          body: await res.text(),
        }
        console.log(`Error: recieved non-200 status code, ${JSON.stringify(data)}`);
        controller.close();
        return
      }
        
      // stream response (SSE) from OpenAI may be fragmented into multiple chunks
      // this ensures we properly read chunks and invoke an event for each SSE event stream
      const parser = createParser(onParse);
      // https://web.dev/streams/#asynchronous-iteration
      for await (const chunk of res.body as any) {
        parser.feed(decoder.decode(chunk));
      }
    },
  });

  let counter = 0;
  const transformStream = new TransformStream({
    async transform(chunk, controller) {
      const data = decoder.decode(chunk);
      // https://beta.openai.com/docs/api-reference/completions/create#completions/create-stream
      if (data === "[DONE]") {
        controller.terminate();
        return;
      }
      try {
        const json = JSON.parse(data);
        const text = json.choices[0].delta?.content || "";
        if (counter < 2 && (text.match(/\n/) || []).length) {
          // this is a prefix character (i.e., "\n\n"), do nothing
          return;
        }
        // stream transformed JSON resposne as SSE
        const payload = {text: text};
        // https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(payload)}\n\n`)
        );
        counter++;
      } catch (e) {
        // maybe parse error
        controller.error(e);
      }
    },
  });

  return readableStream.pipeThrough(transformStream);
}
------------------------
./next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
------------------------
./components/ui/card.tsx
import * as React from "react"

import { cn } from "../utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
------------------------
./components/ui/table.tsx
import * as React from "react"

import { cn } from "/components/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
------------------------
./components/ui/button.tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
------------------------
./components/ui/carousel.tsx
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "../utils"
import { Button } from "./button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
------------------------
./components/LyricsGeneratorForm.tsx
// components/LyricsGeneratorForm.tsx

import React from 'react';

interface LyricsGeneratorFormProps {
  topic: string;
  setTopic: (topic: string) => void;
  originalLyrics: string;
  setOriginalLyrics: (lyrics: string) => void;
  generateLyrics: (e: React.FormEvent<HTMLFormElement>) => Promise<void>;

  loading: boolean;
  generatedLyrics: string;
}

const LyricsGeneratorForm: React.FC<LyricsGeneratorFormProps> = ({
  topic,
  setTopic,
  originalLyrics,
  setOriginalLyrics,
  generateLyrics,
  loading,
  generatedLyrics,
}) => {
    const copyToClipboard = () => {
        navigator.clipboard.writeText(generatedLyrics);
      };
  return (
    <div className="">
      <h2 className="text-2xl mx-auto text-center font-bold">
        2: Pick a Topic
      </h2>
      <div className="flex flex-col space-y-4 mt-4 order-2">
        <input
          className="p-2 max-w-sm mx-auto border text-center rounded"
          placeholder="Topic"
          value={topic}
          onChange={(e) => setTopic(e.target.value)}
        />
        <textarea
          className="p-2 border max-w-md mx-auto text-center rounded"
          placeholder="Original Lyrics"
          rows={10}
          value={originalLyrics}
          onChange={(e) => setOriginalLyrics(e.target.value)}
        ></textarea>
      
      <form className="flex flex-col space-y-4 mt-4 order-2"
  onSubmit={(e) => {
    e.preventDefault();
    generateLyrics(e);
  }}
>
  <button
    type="submit"  // Note the type="submit"
    className="p-2 bg-black text-white max-w-sm mx-auto rounded"
  >
    Generate Lyrics
  </button>
</form>

        
     
        {generatedLyrics && (
          <div className="bg-white rounded p-4 shadow-md flex flex-col overflow-y-auto items-center space-y-2 max-w-md  mx-auto ">
            <h2 className="text-2xl mx-auto text-center font-bold">
              Your Generated Lyrics
            </h2>
            <button onClick={copyToClipboard} className="p-2 bg-black text-white max-w-sm mx-auto rounded">
            Copy to Clipboard
          </button>
            <p className="text-center max-h-md:1/4 overflow-y-auto  whitespace-pre-line">
              {generatedLyrics}
            </p>

          </div>
        )}
      </div>
    </div>
  );
};

export default LyricsGeneratorForm;------------------------
./components/LoadingDots.tsx
import styles from "../styles/loading-dots.module.css";

const LoadingDots = ({
  color = "#000",
  style = "small",
}: {
  color: string;
  style: string;
}) => {
  return (
    <span className={style == "small" ? styles.loading2 : styles.loading}>
      <span style={{ backgroundColor: color }} />
      <span style={{ backgroundColor: color }} />
      <span style={{ backgroundColor: color }} />
    </span>
  );
};

export default LoadingDots;

LoadingDots.defaultProps = {
  style: "small",
};
------------------------
./components/utils.ts
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
------------------------
./components/GitHub.tsx
export default function Github({ className }: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="20"
      height="20"
      fill="currentColor"
      viewBox="0 0 24 24"
      className={className}
    >
      <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
    </svg>
  );
}
------------------------
./components/Footer.tsx
import Link from "next/link";

export default function Footer() {
  return (
    <footer className="text-center h-16 sm:h-20 w-full sm:pt-2 pt-4 border-t mt-5 flex sm:flex-row flex-col justify-between items-center px-3 space-y-3 sm:mb-0 mb-3">
  
    </footer>
  );
}
------------------------
./components/DropDown.tsx
import { Menu, Transition } from "@headlessui/react";
import {
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@heroicons/react/20/solid";
import { Fragment } from "react";

function classNames(...classes: string[]) {
  return classes.filter(Boolean).join(" ");
}

export type VibeType = "Professional" | "Casual" | "Funny";

interface DropDownProps {
  vibe: VibeType;
  setVibe: (vibe: VibeType) => void;
}

let vibes: VibeType[] = ["Professional", "Casual", "Funny"];

export default function DropDown({ vibe, setVibe }: DropDownProps) {
  return (
    <Menu as="div" className="relative block text-left w-full">
      <div>
        <Menu.Button className="inline-flex w-full justify-between items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-black">
          {vibe}
          <ChevronUpIcon
            className="-mr-1 ml-2 h-5 w-5 ui-open:hidden"
            aria-hidden="true"
          />
          <ChevronDownIcon
            className="-mr-1 ml-2 h-5 w-5 hidden ui-open:block"
            aria-hidden="true"
          />
        </Menu.Button>
      </div>

      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items
          className="absolute left-0 z-10 mt-2 w-full origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none"
          key={vibe}
        >
          <div className="">
            {vibes.map((vibeItem) => (
              <Menu.Item key={vibeItem}>
                {({ active }) => (
                  <button
                    onClick={() => setVibe(vibeItem)}
                    className={classNames(
                      active ? "bg-gray-100 text-gray-900" : "text-gray-700",
                      vibe === vibeItem ? "bg-gray-200" : "",
                      "px-4 py-2 text-sm w-full text-left flex items-center space-x-2 justify-between"
                    )}
                  >
                    <span>{vibeItem}</span>
                    {vibe === vibeItem ? (
                      <CheckIcon className="w-4 h-4 text-bold" />
                    ) : null}
                  </button>
                )}
              </Menu.Item>
            ))}
          </div>
        </Menu.Items>
      </Transition>
    </Menu>
  );
}
------------------------
./components/History.tsx
/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/kEUEDqOqrpN
 */
import { TableHead, TableRow, TableHeader, TableCell, TableBody, Table } from "../components/ui/table"
import { Button } from "../components/ui/button"
import { Card } from "../components/ui/card"

export function History({ history }: HistoryProps) {

  return (
    <Card className="w-full mx-auto">
      <Table className="min-w-[600px]">
        <TableHeader>
          <TableRow>
            <TableHead className="w-[200px]">Song Title</TableHead>
            <TableHead>Parody Title</TableHead>
            <TableHead>Artist</TableHead>
            <TableHead>Generation Date</TableHead>
            <TableHead className="justify-center">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {history.map((entry, index) => (
            <TableRow key={index}>
              <TableCell className="font-medium">{entry.songTitle}</TableCell>
              <TableCell>{entry.parodyTitle}</TableCell>
              <TableCell>{entry.artist}</TableCell>
              <TableCell>{entry.generationDate}</TableCell>
              <TableCell className="flex justify-center gap-2">
                {/* Implement view and edit actions if needed */}
                <Button size="sm">View</Button>
                <Button size="sm">Edit</Button>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </Card>
  )
}
------------------------
./components/Header.tsx
import Image from "next/image";
import Link from "next/link";

export default function Header() {
  return (
    <header className="flex justify-center items-center w-full mt-5 border-b-2 pb-7 sm:px-4 px-2">
      <Link href="/" className="flex space-x-3">
      <h1 className="sm:text-3xl pt-6   text-xl font-bold ml-2 tracking-tight">
         Loki 
       </h1>
       <br></br>
        <Image
          alt="header text"
          src="/lokilyrics.png"
          className=" font-bold ml-2 tracking-tight"
          width={90}
          height={90}
         
        />
     
      </Link>
      <a
        href="https://2022.poiesis.education"
        target="_blank"
        rel="noreferrer"
      >
      </a>
    </header>
  );
}
------------------------
./pages/index.tsx
import type { NextPage } from "next";
import { useRef, useState } from "react";
import Header from "../components/Header";
import LoadingDots from "../components/LoadingDots";
import  LyricsGeneratorForm  from '../components/LyricsGeneratorForm';
import { Card, CardContent }  from "../components/ui/card";
import { CarouselItem, CarouselContent, CarouselPrevious, CarouselNext, Carousel } from "../components/ui/carousel";
import { History } from "../components/History";


import {
  createParser,
  ParsedEvent,
  ReconnectInterval,
} from "eventsource-parser";

import GoogleSearchEngine from "../components/GoogleSearchEngine";

import image1 from "../public/light.png";
import image2 from "../public/dark.png";

interface LyricsDecisionCardProps {
  onUseLyrics: (lyrics: string) => void;
  
}

interface LyricsData {
  lyrics: string;
  image: string;
}

const fetchOriginalLyrics = async (
  trackName: string,
  artistName: string
): Promise<LyricsData> => {
  try {
    const response = await fetch(
      `/api/retrieve?track_name=${trackName}&artist_name=${artistName}`
    );
    if (response.ok) {
      const data: LyricsData = await response.json();
      return data;
    }
  } catch (error) {
    console.error("Failed to fetch lyrics:", error);
  }
  return { lyrics: "", image: "" };
};

const LyricsDecisionCard: React.FC<LyricsDecisionCardProps> = ({
  onUseLyrics,
}) => {
  const [showLyrics, setShowLyrics] = useState(false);
  const [lyrics, setLyrics] = useState("");
  const [image, setImage] = useState("");
  const [artistName, setArtistName] = useState("");
  const [trackName, setTrackName] = useState("");

  const tryAgain = () => {
    setShowLyrics(false);
    setLyrics("");
    setImage("");
  };

  const fetchAndShowLyrics = async () => {
    const { lyrics, image } = await fetchOriginalLyrics(trackName, artistName);
    setLyrics(lyrics);
    setImage(image);
    setShowLyrics(true);
  };

  return (
    <div className="order-1 flex flex-col space-y-4 container-mx-auto">
      {!showLyrics ? (
        <div className="object-center mx-auto space-y-4 flex flex-col">
          <input
            className="p-2 border rounded mx-auto max-w-sm"
            type="text"
            placeholder="Artist Name"
            value={artistName}
            onChange={(e) => setArtistName(e.target.value)}
          />
          <input
            className="p-2 border rounded mx-auto max-w-sm"
            type="text"
            placeholder="Track Name"
            value={trackName}
            onChange={(e) => setTrackName(e.target.value)}
          />
          <button
            className="p-2 bg-black text-white max-w-sm mx-auto rounded"
            onClick={fetchAndShowLyrics}
          >
            Fetch Lyrics
          </button>
        </div>
      ) : (
        <div className="sticky">
          <div className="bg-white rounded p-4 shadow-md flex flex-col items-center space-y-2 max-w-md mx-auto ">
            <h2 className="text-xl font-semibold sticky-0 items-center">
              Original Lyrics
            </h2>
            {image && (
              <img
                className="w-40 h-40 object-center rounded"
                src={image}
                alt={`${trackName} by ${artistName}`}
              />
            )}
            <div className="flex space-x-2">
              <button
                className="p-2 bg-black text-white rounded"
                onClick={() => onUseLyrics(lyrics)}
              >
                Use These Lyrics
              </button>
              <button
                className="p-2 bg-blue-700 text-white rounded"
                onClick={tryAgain}
              >
                Try Again
              </button>
            </div>
            <div className="max-h-40 overflow-y-auto">
              <p className="text-center whitespace-pre-line">{lyrics}</p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
const ClickableImage: React.FC = () => {
  const [isImageOne, setIsImageOne] = useState(true);

  const handleClick = () => {
    setIsImageOne(!isImageOne);
  };

  return (
    <img
      className="w-40 h-40 mx-auto rounded"
      src={isImageOne ? '/dark.png' : '/light.png' }
      alt="clickable"
      onClick={handleClick}
    />
  );
};







const LyricsGenerator: NextPage = () => {
  const [loading, setLoading] = useState(false);
  const [topic, setTopic] = useState("");
  const [originalLyrics, setOriginalLyrics] = useState("");
  const [generatedLyrics, setGeneratedLyrics] = useState("");
  const [history, setHistory] = useState([]);
  const lyricsRef = useRef<null | HTMLDivElement>(null);

  const scrollToLyrics = () => {
    if (lyricsRef.current !== null) {
      lyricsRef.current.scrollIntoView({ behavior: "smooth" });
    }
  };
  const fetchOriginalLyrics = async (trackName: string, artistName: string) => {
    try {
      const response = await fetch(`/api/${trackName}/${artistName}`);
      if (response.ok) {
        const data = await response.json();
        setOriginalLyrics(data.lyrics);
      }
    } catch (error) {
      console.error("Failed to fetch lyrics:", error);
    }
  };

  const generateLyrics = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setGeneratedLyrics("");
    setLoading(true);

    const prompt = `Your task is to rewrite the lyrics of a given song to revolve around a specific topic provided. The goal is to keep the original rhythm and structure of the song, adapting and substitifying words to create a new set of lyrics in line with the given theme. You should stay true to the song's rhyme scheme and musicality, whilst making sure the lyrics provide a coherent narrative around the topic and can be sung with the same tune of the song. Your input would be the original lyrics of the song, along with the specified topic, and your output would be the adapted lyrics revolving around that topic. While rewriting, remember to not only focus on thematic relevance but also ensure that your lyrics preserve the musical appeal of the original song. Essentially, you're creating a completely different version of the song that can stand on its own while staying true to the original's musical qualities. Topic:  "${topic}" Original lyrics: ${originalLyrics} Please provide the lyrics line by line.`;

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        prompt,
      }),
    });

    if (!response.ok) {
      throw new Error(response.statusText);
    }

    const data = response.body;
    if (!data) {
      return;
    }

    const onParse = (event: ParsedEvent | ReconnectInterval) => {
      if (event.type === "event") {
        const data = event.data;
        try {
          const text = JSON.parse(data).text ?? "";
          setGeneratedLyrics((prev) => prev + text);
          setHistory((prevHistory) => [...prevHistory, { songTitle: "Your Song Title", parodyTitle: "Your Parody Title", artist: "Artist Name", generationDate: new Date().toISOString().split('T')[0], lyrics: generatedLyrics }]);
        } catch (e) {
          console.error(e);
        }
      }
    };

    const reader = data.getReader();
    const decoder = new TextDecoder();
    const parser = createParser(onParse);
    let done = false;
    while (!done) {
      const { value, done: doneReading } = await reader.read();
      done = doneReading;
      const chunkValue = decoder.decode(value);
      parser.feed(chunkValue);
    }
    scrollToLyrics();
    setLoading(false);
  };

  return (
    <div className="container w-full  mx-auto p-4 max-height">
     
     <main className="flex justify-center items-center min-h-screen pt-20">      
     <Carousel className="w-full max-w-xxl mx-auto">      
      <CarouselContent>
        <CarouselItem>
            <Card>
              <CardContent className="w-half flex items-center justify-center p-6 gap-4 flex-col">
                <LyricsDecisionCard
                  onUseLyrics={(lyrics: string) => setOriginalLyrics(lyrics)}
                />
              </CardContent>
            </Card>
          
        </CarouselItem>
        <CarouselItem>
          <div className="p-1">
            <Card>
              <CardContent className="flex items-center justify-center  p-6 gap-4 flex-col ">
                <LyricsGeneratorForm
                  topic={topic}
                  setTopic={setTopic}
                  originalLyrics={originalLyrics}
                  setOriginalLyrics={setOriginalLyrics}
                  generateLyrics={generateLyrics}
                  loading={loading}
                  generatedLyrics={generatedLyrics}
                />
              </CardContent>
            </Card>
          </div>
        </CarouselItem>
        <CarouselItem >
        <Card  >
          <CardContent className="flex items-center justify-center p-6 gap-4 flex-col">
          <History history={history} />
        </CardContent>
        </Card>

        </CarouselItem>
      </CarouselContent>
      <CarouselNext />
      <CarouselPrevious />

    </Carousel>
   

  

        
         
      </main>
    </div>
  );
};

export default LyricsGenerator;
------------------------
./pages/_document.tsx
import Document, { Head, Html, Main, NextScript } from "next/document";

class MyDocument extends Document {
  render() {
    return (
      <Html lang="en">
        <Head>
          <link rel="icon" href="/favicon.ico" />
          <meta
            name="description"
            content="Give a song and a topic, get a song about that topic"
          />
          <meta property="og:site_name" content="poet.poiesis.education" />
          <meta
            property="og:description"
            content="Give a song and a topic, get a song about that topic"
          />
          <meta property="og:title" content="Twitter Bio Generator" />
          <meta name="twitter:card" content="summary_large_image" />
          <meta name="twitter:title" content="Twitter Bio Generator" />
          <meta
            name="twitter:description"
            content="Give a song and a topic, get a song about that topic"
          />
          <meta
            property="og:image"
            content="https://poet.poiesis.education/og-image.png"
          />
          <meta
            name="twitter:image"
            content="https://poet.poiesis.education/og-image.png"
          />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;
------------------------
./pages/api/retrieve.ts
import { NextApiRequest, NextApiResponse } from 'next';
import axios from 'axios';
import rateLimit from 'axios-rate-limit';

// Define Axios error type
interface AxiosError extends Error {
  response?: {
    status: number;
    data: any;
  };
}

const http = rateLimit(axios.create(), { maxRequests: 150, perMilliseconds: 60 * 60 * 1000 });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { track_name, artist_name } = req.query;

  try {
    const response = await http.get(`https://lyrist.vercel.app/api/${track_name}/${artist_name}`);
    const { lyrics, image } = response.data;
    if (lyrics && image) {
      res.status(200).json({ lyrics, image });
    } else {
      res.status(404).json({ message: "Lyrics or image not found" });
    }
  } catch (error: unknown) {
    if (error instanceof Error) {
      const axiosError = error as AxiosError;
      res.status(axiosError.response?.status || 500).json(axiosError.response?.data || {});
    } else {
      res.status(500).json({ message: "Unknown error" });
    }
  }
}
------------------------
./pages/api/generate.ts
import { OpenAIStream, OpenAIStreamPayload } from "../../utils/OpenAIStream";

if (!process.env.OPENAI_API_KEY) {
  throw new Error("Missing env var from OpenAI");
}

// Default to 'gpt-4' if MODEL_TYPE isn't specified
const modelType = process.env.MODEL_TYPE || 'gpt-4';

export const config = {
  runtime: "edge",
};

const handler = async (req: Request): Promise<Response> => {
  const { prompt } = (await req.json()) as {
    prompt?: string;
  };

  if (!prompt) {
    return new Response("No prompt in the request", { status: 400 });
  }

  const payload: OpenAIStreamPayload = {
    model: modelType,  
    messages: [{ role: "user", content: prompt }],
    temperature: 0.7,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
    max_tokens: 1000,
    stream: true,
    n: 1,
  };

  const stream = await OpenAIStream(payload);
  return new Response(
    stream, {
      headers: new Headers({
        'Cache-Control': 'no-cache',
      })
    }
  );
};

export default handler;
------------------------
./pages/_app.tsx
import { Analytics } from "@vercel/analytics/react";
import type { AppProps } from "next/app";
import "../styles/globals.css";

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Component {...pageProps} />
      <Analytics />
    </>
  );
}

export default MyApp;
------------------------
